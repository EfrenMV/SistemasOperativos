* Titulo principal
** subtitulo
*** sub-titul|o

- Aqui hay una lista
  Elemento en la lsita
  Segundo elemento en la lista
  - Nueva lista en lista
    Elemento

1. Primeer elemento
   1.1 Texto en primer elemento

2. Segundo elemento
   2.1 elemento
   
Si queremos habrir titlos es con TAP

si queremos ejecutar es darle ctrl+c y yes

* Ejemplo de código en C
*** subtitulo
#+BEGIN_SRC C
  #include <stdio.h>

  int main() {
    printf("Hola, mundo desde probado C!\n");
    return 0;
  }
#+END_SRC

#+RESULTS:
| Hola | mundo desde probado C! |







*  Sistemas Operativo
** Comandos para manejar procesos en Linux
*** Ver proceos activos
*ps*
Muestra una lista de proceos en la terminal actual

*ps aux*
Muetra todos los proceos en ejecución en el sistema

*top*
Muestra una lista dinámica de proceos en tiempo real

*htop*
Ofrece una in
*** Iniciar procesos activos
*** Controlar la ejecución de proceos
*** Enviar señales a los procesos
*** Cambiar prioridad de proceos
*** Ver detalles especificos de los proceos
ps:
Muestra una lista de proceos en la terminal actual
(PID,usuario,CPU,memoria, etc)

ps aux:
Muestra todos los proceos en ejecución en el sistema

top:
Muestra una lista dinamica de procesos en tiempo real, catualizandose constantemente
(CPU,memoria y estadistica del sistema)

htop:
Muestra una interfaz mas visual y personalizable que top

pgrep<nombre>
Busca el PID (Process ID) de un proceso en especifico por su nombre

pgrep apache
muestra el PID del proceso con el nombre "apache"
** Punteros en C
** Concepto de proceos
** Fork() en c
** Estados y transiciones de los proceos*
** Tabla de Proceos
** Proceos ligeros: Hilos o hebras
** pthread create en C
** Cola con prioridad
** Concurrencia y Secuencialidad
*** Ejemplo en C: Concurrencia y Sincronización de tareas
*** 1.1 Exclusión Mutua
**** Dekker
***** Ejemplo de algoritmo de Dekker
#+BEGIN_SRC C
   #include <stdio.h>
 #include <pthread.h>
 #include <stdbool.h>

 bool flag[2] = {false, false};
 int turn = 0;

 void* proceso(void* arg) {
     int i = *(int*)arg;
     int j = 1 - i;
     flag[i] = true;
     while (flag[j]) {
         if (turn != i) {
             flag[i] = false;
             while (turn != i);
             flag[i] = true;
         }
     }
     // Sección Crítica
     printf("Proceso %d en sección crítica\n", i);
     turn = j;
     flag[i] = false;
     
 }

 int main() {
     pthread_t t0, t1;
     int id0 = 0, id1 = 1;
     pthread_create(&t0, NULL, proceso, &id0);
     pthread_create(&t1, NULL, proceso, &id1);
     pthread_join(t0, NULL);
     pthread_join(t1, NULL);
     return 0;
 }
#+END_SRC

#+RESULTS:
| Proceso | 0 | en | sección | crítica |
| Proceso | 1 | en | sección | crítica |
***** Productor Consumod Dekker
#+BEGIN_SRC C
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

typedef struct _nodo {
    int valor;
    struct _nodo *siguiente;
} nodo;

nodo* cabeza = NULL; // Cola de procesos

int turno = 0;           // Variable de turno para el algoritmo de Dekker
int interesado[2] = {0, 0};  // Indica si el productor o consumidor están interesados

void insertar_final(int valor) {
    nodo* nuevo = (nodo*)malloc(sizeof(nodo));
    nuevo->valor = valor;
    nuevo->siguiente = cabeza;
    cabeza = nuevo;
    printf("Productor produjo: %d\n", valor);
}

void atender_proceso() {
    if (cabeza != NULL) {
        nodo* temp = cabeza;
        cabeza = cabeza->siguiente;
        printf("Consumidor atendió: %d\n", temp->valor);
        free(temp);
    } else {
        printf("No hay procesos para consumir\n");
    }
}

// Función de productor utilizando algoritmo de Dekker
void* productor(void* arg) {
    for (int i = 0; i < 5; i++) {
        interesado[0] = 1;
        while (interesado[1]) {
            if (turno != 0) {
                interesado[0] = 0;
                while (turno != 0);
                interesado[0] = 1;
            }
        }
        
        insertar_final(i + 1); // Zona crítica
        
        turno = 1;
        interesado[0] = 0;
        sleep(1); // Simular producción
    }
    return NULL;
}

// Función de consumidor utilizando algoritmo de Dekker
void* consumidor(void* arg) {
    for (int i = 0; i < 5; i++) {
        interesado[1] = 1;
        while (interesado[0]) {
            if (turno != 1) {
                interesado[1] = 0;
                while (turno != 1);
                interesado[1] = 1;
            }
        }
        
        atender_proceso(); // Zona crítica
        
        turno = 0;
        interesado[1] = 0;
        sleep(1); // Simular consumo
    }
    return NULL;
}

int main() {
    pthread_t hilo_productor, hilo_consumidor;
    
    pthread_create(&hilo_productor, NULL, productor, NULL);
    pthread_create(&hilo_consumidor, NULL, consumidor, NULL);
    
    pthread_join(hilo_productor, NULL);
    pthread_join(hilo_consumidor, NULL);
    
    return 0;
}
#+END_SRC 

#+RESULTS:
| No         | hay      | procesos | para | consumir |
| Productor  | produjo: |        1 |      |          |
| Productor  | produjo: |        2 |      |          |
| Consumidor | atendió: |        2 |      |          |
| Productor  | produjo: |        3 |      |          |
| Consumidor | atendió: |        3 |      |          |
| Consumidor | atendió: |        1 |      |          |
| Productor  | produjo: |        4 |      |          |
| Consumidor | atendió: |        4 |      |          |
| Productor  | produjo: |        5 |      |          |

**** Peterson
***** Ejemplo de algortimo de peterson
#+BEGIN_SRC C
  

#include <stdio.h>
#include <pthread.h>
#include <stdbool.h>

bool flag[2] = {false, false};
int turn;

void* proceso(void* arg) {
    int i = *(int*)arg;
    int j = 1 - i;
    flag[i] = true;
    turn = j;
    while (flag[j] && turn == j);
    // Sección Crítica
    printf("Proceso %d en sección crítica\n", i);
    flag[i] = false;
    return NULL;
}

int main() {
    pthread_t t0, t1;
    int id0 = 0, id1 = 1;
    pthread_create(&t0, NULL, proceso, &id0);
    pthread_create(&t1, NULL, proceso, &id1);
    pthread_join(t0, NULL);
    pthread_join(t1, NULL);
    return 0;
}
#+END_SRC

#+RESULTS:
| Proceso | 0 | en | sección | crítica |
| Proceso | 1 | en | sección | crítica |

***** Productor Consumidor Peterson
#+BEGIN_SRC C
  
  #include <stdio.h>
  #include <stdlib.h>
  #include <pthread.h>
  #include <unistd.h>

  #define MAX_PROCESOS 10

  typedef struct _nodo {
      int valor;
      int prioridad;
      struct _nodo *siguiente;
  } nodo;

  nodo* cabeza = NULL;

  int turno = 0;
  int interesado[2] = {0, 0};

  int numero_aleatorio() {
      return (rand() % 4) + 1;
  }

  nodo* genera_proceso(int id) {
      nodo* nuevo = (nodo*)malloc(sizeof(nodo));
      nuevo->valor = id;
      nuevo->prioridad = numero_aleatorio();
      nuevo->siguiente = NULL;
      return nuevo;
  }

  void* productor(void* arg) {
      int id = *(int*)arg;
      for (int i = 0; i < 5; i++) {
	  interesado[0] = 1;
	  turno = 1;
	  while (interesado[1] && turno == 1);

	  nodo* nuevo = genera_proceso(id * 10 + i);
	  nuevo->siguiente = cabeza;
	  cabeza = nuevo;
	  printf("Productor %d generó proceso %d con prioridad %d\n", id, nuevo->valor, nuevo->prioridad);

	  interesado[0] = 0;
	  sleep(1);
      }
      return NULL;
  }

  void* consumidor(void* arg) {
      int id = *(int*)arg;
      for (int i = 0; i < 5; i++) {
	  interesado[1] = 1;
	  turno = 0;
	  while (interesado[0] && turno == 0);

	  if (cabeza != NULL) {
	      nodo* temp = cabeza;
	      cabeza = cabeza->siguiente;
	      printf("Consumidor %d atendió proceso %d con prioridad %d\n", id, temp->valor, temp->prioridad);
	      free(temp);
	  } else {
	      printf("No hay procesos para consumir\n");
	  }

	  interesado[1] = 0;
	  sleep(1);
      }
      return NULL;
  }

  int main() {
      srand(time(NULL));
      pthread_t hilo_productor, hilo_consumidor;
      int id_productor = 1, id_consumidor = 2;

      pthread_create(&hilo_productor, NULL, productor, &id_productor);
      pthread_create(&hilo_consumidor, NULL, consumidor, &id_consumidor);

      pthread_join(hilo_productor, NULL);
      pthread_join(hilo_consumidor, NULL);

      return 0;
  }


#+END_SRC

#+RESULTS:
| Productor  |   1 | generó   | proceso |       10 | con | prioridad | 3 |
| Consumidor |   2 | atendió  | proceso |       10 | con | prioridad | 3 |
| Productor  |   1 | generó   | proceso |       11 | con | prioridad | 4 |
| Consumidor |   2 | atendió  | proceso |       11 | con | prioridad | 4 |
| No         | hay | procesos | para    | consumir |     |           |   |
| Productor  |   1 | generó   | proceso |       12 | con | prioridad | 3 |
| Consumidor |   2 | atendió  | proceso |       12 | con | prioridad | 3 |
| Productor  |   1 | generó   | proceso |       13 | con | prioridad | 1 |
| Consumidor |   2 | atendió  | proceso |       13 | con | prioridad | 1 |
| Productor  |   1 | generó   | proceso |       14 | con | prioridad | 2 |
**** Lamport’s Bakery
***** Ejemplo de algoritmo de Lamport´s Bakery
#+BEGIN_SRC C
  #include <stdio.h>
       #include <pthread.h>
       #include <stdbool.h>

       #define NUM_PROCESOS 3
       bool choosing[NUM_PROCESOS];
       int number[NUM_PROCESOS];

       void* proceso(void* arg) {
           int i = *(int*)arg;

           choosing[i] = true;
           number[i] = 1;
           for (int j = 0; j < NUM_PROCESOS; j++) {
               if (number[j] > number[i]) number[i] = number[j] + 1;
           }
           choosing[i] = false;

           for (int j = 0; j < NUM_PROCESOS; j++) {
               while (choosing[j]);
               while (number[j] != 0 && (number[j] < number[i] || (number[j] == number[i] && j < i)));
           }

           printf("Proceso %d en sección crítica\n", i);

           number[i] = 0;
           return NULL;
       }

       int main() {
           pthread_t threads[NUM_PROCESOS];
           int ids[NUM_PROCESOS];
           for (int i = 0; i < NUM_PROCESOS; i++) {
               ids[i] = i;
               pthread_create(&threads[i], NULL, proceso, &ids[i]);
           }
           for (int i = 0; i < NUM_PROCESOS; i++) {
               pthread_join(threads[i], NULL);
           }
           return 0;
       }
#+END_SRC

#+RESULTS:
| Proceso | 0 | en | sección | crítica |
| Proceso | 2 | en | sección | crítica |
| Proceso | 1 | en | sección | crítica |

***** Productor Consumidor Lamport´s Bakery
#+BEGIN_SRC C
  #include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define MAX_PROCESOS 10

typedef struct _nodo {
    int valor;
    int prioridad;
    struct _nodo *siguiente;
} nodo;

nodo* cabeza = NULL;

int turno[2];
int eligiendo[2] = {0, 0};

int numero_aleatorio() {
    return (rand() % 4) + 1;
}

nodo* genera_proceso(int id) {
    nodo* nuevo = (nodo*)malloc(sizeof(nodo));
    nuevo->valor = id;
    nuevo->prioridad = numero_aleatorio();
    nuevo->siguiente = NULL;
    return nuevo;
}

int max_turno() {
    return turno[0] > turno[1] ? turno[0] : turno[1];
}

void* productor(void* arg) {
    int id = *(int*)arg;
    for (int i = 0; i < 5; i++) {
        eligiendo[0] = 1;
        turno[0] = max_turno() + 1;
        eligiendo[0] = 0;

        while (eligiendo[1]);
        while (turno[1] != 0 && (turno[1] < turno[0] || (turno[1] == turno[0] && 1 < 0)));

        nodo* nuevo = genera_proceso(id * 10 + i);
        nuevo->siguiente = cabeza;
        cabeza = nuevo;
        printf("Productor %d generó proceso %d con prioridad %d\n", id, nuevo->valor, nuevo->prioridad);

        turno[0] = 0;
        sleep(1);
    }
    return NULL;
}

void* consumidor(void* arg) {
    int id = *(int*)arg;
    for (int i = 0; i < 5; i++) {
        eligiendo[1] = 1;
        turno[1] = max_turno() + 1;
        eligiendo[1] = 0;

        while (eligiendo[0]);
        while (turno[0] != 0 && (turno[0] < turno[1] || (turno[0] == turno[1] && 0 < 1)));

        if (cabeza != NULL) {
            nodo* temp = cabeza;
            cabeza = cabeza->siguiente;
            printf("Consumidor %d atendió proceso %d con prioridad %d\n", id, temp->valor, temp->prioridad);
            free(temp);
        } else {
            printf("No hay procesos para consumir\n");
        }

        turno[1] = 0;
        sleep(1);
    }
    return NULL;
}

int main() {
    srand(time(NULL));
    pthread_t hilo_productor, hilo_consumidor;
    int id_productor = 1, id_consumidor = 2;

    pthread_create(&hilo_productor, NULL

#+END_SRC

#+RESULTS:

*** 1.2 Sincronización
*** 1.3 condiciones de carrera y sincronización 

** Secuencialidad
** Niveles, Objetivos y Criterios de Planificación
** Técnicas de Administración del Planificador

** Iniciar Prcesos
&:
Ejecuta un comando en segundo plano, permitiendo que el usuario continua
usando la terminal

1. Ejemplo
  "comadno &" ejecuta el proceso en segundo plano

nohup<comando> &
Inicia un proceso que continau en ejecucion incluso despues de
cerrar la terminal

1. Ejemplo
   "nohup scrip.sh &" ejecuta "script.sh" y permanece activo tras cerrar sesión

** Controlar la ejecución de procesos
fg:
Trae un proceos en segundo plano al primer plano, permitiendo interactuar con el

bg:
Envia un proceso suspendido al segundo plano. Libera la terminal pa otro comando

jobs:
Muestra los procesos en segundo plano o suspendidos con su ID de trabajo (job ID)

** Enviar señales a los procesos
a
** Concurrencia y Secuencialidad
*** Concepto
Estos permiten que multiples proceos y threads se ejecuten al mismo tiempo

Concurrencia
Permite ejecutar multiples tareas "simultáneamente". Aunquen o siempre ejecuta
al mismo tiempo

  Objetivo: Permitir Multiples procesos compartan el CPU y otros recursos
            de manera eficiente y sin conflictos

  Desafios: Sincronización de acceso a recursos compartidos, evitar condiciones
            de carrera y gestionar la exclusión mutua.

*** Ejemplo en C: Concurrencia y sincronización de tareas
#+BEGIN_SRC C
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

void* tarea1(void* arg) {
    printf("Inicio de tarea 1\n");
    sleep(1);
    printf("Fin de tarea 1\n");
    return NULL;
}

void* tarea2(void* arg) {
    printf("Inicio de tarea 2\n");
    sleep(1);
    printf("Fin de tarea 2\n");
    return NULL;
}

int main() {
    pthread_t hilo1, hilo2;
    pthread_create(&hilo1, NULL, tarea1, NULL);
    pthread_create(&hilo2, NULL, tarea2, NULL);

    pthread_join(hilo1, NULL);
    pthread_join(hilo2, NULL);
    printf("Ambas tareas han terminado de forma concurrente\n");
    return 0;
}

#+END_SRC

#+RESULTS:
| Inicio | de     | tarea |         2 |    |       |             |
| Inicio | de     | tarea |         1 |    |       |             |
| Fin    | de     | tarea |         1 |    |       |             |
| Fin    | de     | tarea |         2 |    |       |             |
| Ambas  | tareas | han   | terminado | de | forma | concurrente |

*** Exclusión Mutua
**** Concepto
La exclusión mutua asegura que solo un proceso a la vez puede acceder a una
sección critica que manipula recursos compartidos
**** Algoritmos comunes

***** Algoritmo de Dekker
****** Concepto
Algoritmo de programación concurrente para exclusión mutua
permite que dos procesos o hilos de ejecución compartartan un
recurso son conflictos

Si ambos intentan acceder a la seccion critica simultaneamente,
el algoritmo elige un proceso segun una varibale de turno

****** Condiciones

  *No hay prioridad entre procesos.
  *La capacidad de los equipos es irrelevante.
  *Si un proceso muere fuera de la región critica, el algoritmo sigue
   funcionando.
  *Un bloque mutio no se concidera como solución valida.

****** Verciones

******* Alternancia Estricta
******* Problema Interbloqueo
******* Colisión region critica
******* Postergación Indefinida
******* Variables
******* Turno
******* Matemática


****** Ejemplos en C algoritmo de Dekker
#+BEGIN_SRC C
#include <stdio.h>
 #include <pthread.h>
 #include <stdbool.h>

 bool flag[2] = {false, false};
 int turn = 0;

 void* proceso(void* arg) {
     int i = *(int*)arg;
     int j = 1 - i;
     flag[i] = true;
     while (flag[j]) {
         if (turn != i) {
             flag[i] = false;
             while (turn != i);
             flag[i] = true;
         }
     }
     // Sección Crítica
     printf("Proceso %d en sección crítica\n", i);
     turn = j;
     flag[i] = false;
     return NULL;
 }

 int main() {
     pthread_t t0, t1;
     int id0 = 0, id1 = 1;
     pthread_create(&t0, NULL, proceso, &id0);
     pthread_create(&t1, NULL, proceso, &id1);
     pthread_join(t0, NULL);
     pthread_join(t1, NULL);
     return 0;
 }
#+END_SRC

#+RESULTS:
| Proceso | 1 | en | sección | crítica |
| Proceso | 0 | en | sección | crítica |

***** Algoritmo de Peterson
***** Algoritmo de Lamport´s Bakery
***** Semáforos y Mutexes
** Sincronización
*** Concepto
La sincronización se encarga de coordinar la ejecución de multiples proceso

*** Semáforos de Dijkstra
Usados para la sincronización y control de acceso a recursos mediante dos tipos

  Semáforo Binario (mutex)
  Semáforo contaodr (permite múltiples accesos)

*** Monitores
Estructuras que permiten que los procesos esperen hasta que una condición
se cumpĺa

*** Condiciones de carrera y sincronización
Las condiciones de carrera ocurren cuando dos o más proceos acceden a recursos
compartidos de manera concurrente y el resultado depnede del orden de ejecución

Son:
  Bloqueos de exclusón mutua
  Sincronización a traves de semáforos y monitores

*  Secuencialidad
Esto implica gestionar el orden de ejecución de los proceos o
threads en un sistmea operativo para asegura que se cumplan ciertos
requisitos de rendimiento o justicia en el acceso a recursos.


 *Objetivo*: Asignar CPU a los proceso de forma que se minimicen tiempos
  de espera y maximicen el uso del procesador.

** Algoritmos de Planificación de Procesos
*** Concepto
Determinan el orden que se ejecutan los procesos en la CPU
*** Los mas comunes
***** First-Come, First-Serverd(FCFS
Los procesos se ejcutan en el orden de llegada
***** Shortest Job Next(SJN)
El proceos con tiempo de ejecución mas corto tiene prioridad
***** Round Robin (RR)
Cada uno tiene una cantidad fija de tiempo de CPU y despues pasa al final de la cola
***** Multilevel Queue Scheduling
Se agrupan en diferentes colas, cada una con su propio algoritmo de planificación
***** Priority Scheduling
Procesos con mayor prioridad se ejecutan primero, lo cual requiere un manejo
cuidadoso para evirar el "hambruna" de procesos de baja prioridad
** Algoritmos de Detección y Prevención de Interbloquos (Deadlocks)
*** Concepto
Interbloqueos: Ocurren cuando dos o mas proceos esperan indifinidamente por
               recursos que otros procesos poseen.
	       
*** Condiciones para un Interbloqueo
  Exclusión muta
  Retención y espera
  No apropiación
  Espera Circular
*** Métodos de Prevención

*Algoritmo del banquero de Dijkstra*: Evalúa si la asignación de recursos
donde prodia llevar a un estado seguro o ptencialmente inseguro.

*Prevención de interbloqueos*: Evita que se cumplan las condiciones para un
interbloqueo.

** Sincronización y Secuencialidad
*** Concepto
Evitan conflictos y maximizan el rendimiento
*** Tecnicas
*Wait-for Graphs*: Muestra las dependencias de los recuros para detectar
                   posibles interbloqueos.
*Petri Nets*: Son Herramientas visuales para analizar sistemas concurrentes
              y modelar sincronización y sencuancialidad

** Niveles, Objetivos y Criterios de Planificación
** Concepto
*Planificación*: Proceso de asignar recursos del sistema a los procesos
** Niveles
*** Planificación a largo plazo
Selecciona qué procesos ingresar al sistema
*** Planificación a medio plazo
Decide qué proceos en espera se vuelven listos
*** Planificación a corto plazo
Selecciona qué proceos listo ocupa la CPU
** Implementación simple de planificación Round Robin en C
#+BEGIN_SRC C
  #include <stdio.h>
  #include <unistd.h>

  
  void proceso(int id) {
      printf("Proceso %d en ejecución\n", id);
      sleep(1); // Tiempo simulado de ejecución del proceso
      printf("Proceso %d terminado\n", id);
  }

  int main() {
      int n_procesos = 3;
      for (int i = 0; i < n_procesos; i++) {
	  proceso(i);
      }
      return 0;
  }
#+END_SRC

#+RESULTS:
| Proceso | 0 | en        | ejecución |
| Proceso | 0 | terminado |           |
| Proceso | 1 | en        | ejecución |
| Proceso | 1 | terminado |           |
| Proceso | 2 | en        | ejecución |
| Proceso | 2 | terminado |           |

** Técnicas de administración del planificador
*** Round Robin
Asigna a cada proceso una franja de tiempo
*** Prioridad
De preferencia a procesos con alta prioridad
*** Planificación en el tiempo real
Asegura que las tareas criticas se ejecuten en el momento correcto
*** Ejemplo en C: Planificación simple basada en prioridades
#+BEGIN_SRC C
  #include <stdio.h>
#include <stdlib.h>

typedef struct {
    int id;
    int prioridad;
} Proceso;

void ejecutar(Proceso p) {
    printf("Ejecutando proceso %d con prioridad %d\n", p.id, p.prioridad);
}

int main() {
    Proceso procesos[] = {{1, 2}, {2, 1}, {3, 3}};
    int n = sizeof(procesos) / sizeof(procesos[0]);

    // Ordenar procesos por prioridad
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            if (procesos[i].prioridad > procesos[j].prioridad) {
                Proceso temp = procesos[i];
                procesos[i] = procesos[j];
                procesos[j] = temp;
            }
        }
    }

    for (int i = 0; i < n; i++) {
        ejecutar(procesos[i]);
    }

    return 0;
}
#+END_SRC

#+RESULTS:
| Ejecutando | proceso | 2 | con | prioridad | 1 |
| Ejecutando | proceso | 1 | con | prioridad | 2 |
| Ejecutando | proceso | 3 | con | prioridad | 3 |

*** Ejercicios
**** Procesos División por restas, Potencias con sumas, Fork
#+BEGIN_SRC C
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdlib.h>

// Función recursiva para división por restas
int division_por_restas(int dividendo, int divisor, int cociente) {
    if (dividendo < divisor) {
        printf("División por restas: Cociente = %d, Residuo = %d\n", cociente, dividendo);
        return cociente;
    }
    return division_por_restas(dividendo - divisor, divisor, cociente + 1);
}

// Función recursiva para multiplicación por sumas
int multiplicacion_por_sumas(int multiplicando, int multiplicador) {
    if (multiplicador == 0) {
        return 0;
    }
    return multiplicando + multiplicacion_por_sumas(multiplicando, multiplicador - 1);
}

int main() {

  int pid = fork();
    if (pid < 0) {
        perror("Error al crear el proceso");
        return 1;
    } else if (pid == 0) {
      printf("valor del pid hijo %d \n", pid);
      // Proceso hijo: realiza la división por restas de forma recursiva
        int dividendo = 20, divisor = 3;
        division_por_restas(dividendo, divisor, 0);
    } else {
        // Proceso padre: realiza la multiplicación por sumas de forma recursiva
       printf("valor del pid padre %d \n", pid);
     
      int multiplicando = 4, multiplicador = 5;
        wait(NULL);  // Espera a que el proceso hijo termine
        int producto = multiplicacion_por_sumas(multiplicando, multiplicador);
        printf("Multiplicación por sumas: Producto = %d\n", producto);
    }

    return 0;
}
#+END_SRC

#+RESULTS:
| valor          | del | pid     | hijo     |    0 |    |         |   |   |
| División       | por | restas: | Cociente |    = | 6, | Residuo | = | 2 |
| valor          | del | pid     | padre    | 5844 |    |         |   |   |
| Multiplicación | por | sumas:  | Producto |    = | 20 |         |   |   |

**** Hulos División por restas, Potencias con sumas phread
#+BEGIN_SRC C
#include <stdio.h>
#include <pthread.h>

// Estructura para los parámetros de los hilos
typedef struct {
    int numero1;
    int numero2;
} Parametros;

// Función recursiva para división por restas
void* division_por_restas(void* args) {
    Parametros* params = (Parametros*) args;
    int dividendo = params->numero1;
    int divisor = params->numero2;

    int division_recursiva(int dividendo, int divisor, int cociente) {
        if (dividendo < divisor) {
            printf("División por restas: Cociente = %d, Residuo = %d\n", cociente, dividendo);
            return cociente;
        }
        return division_recursiva(dividendo - divisor, divisor, cociente + 1);
    }

    division_recursiva(dividendo, divisor, 0);
    pthread_exit(NULL);
}

// Función recursiva para multiplicación por sumas
void* multiplicacion_por_sumas(void* args) {
    Parametros* params = (Parametros*) args;
    int multiplicando = params->numero1;
    int multiplicador = params->numero2;

    int multiplicacion_recursiva(int multiplicando, int multiplicador) {
        if (multiplicador == 0) {
            return 0;
        }
        return multiplicando + multiplicacion_recursiva(multiplicando, multiplicador - 1);
    }

    int producto = multiplicacion_recursiva(multiplicando, multiplicador);
    printf("Multiplicación por sumas: Producto = %d\n", producto);
    pthread_exit(NULL);
}

int main() {
    pthread_t hilo1, hilo2;
    Parametros params_division = {20, 3};    // Parámetros para la división
    Parametros params_multiplicacion = {4, 5}; // Parámetros para la multiplicación

    // Crear el hilo para la división por restas recursiva
    if (pthread_create(&hilo1, NULL, division_por_restas, (void*) &params_division) != 0) {
        perror("Error al crear el hilo de división");
        return 1;
    }

    // Crear el hilo para la multiplicación por sumas recursiva
    if (pthread_create(&hilo2, NULL, multiplicacion_por_sumas, (void*) &params_multiplicacion) != 0) {
        perror("Error al crear el hilo de multiplicación");
        return 1;
    }

    // Esperar a que los hilos terminen
    pthread_join(hilo1, NULL);
    pthread_join(hilo2, NULL);

    return 0;
}
#+END_SRC

#+RESULTS:
| División       | por | restas: | Cociente | = | 6, | Residuo | = | 2 |
| Multiplicación | por | sumas:  | Producto | = | 20 |         |   |   |
